#include <stdio.h>
int bitAnd(int x, int y); // x&y, используя ~ and |
int bitXor(int x, int y); // x^y , используя ~ and &
int thirdBits(); // возвращает int, каждый третий бит которого, считая с младшего, 1, остальные биты 0
int fitsBits(int x, int n); // возвращает 1, если x может быть представлен на машине с n-разрядами(доп. код)
int sign(int x); // возвращает 1, 0 и -1, если x> 0, x== 0, x< 0 соответственно
int getByte(int x, int n); // извлекает n-ый байт из x
int logicalShift(int x, int n); // сдвигает биты x вправо по правилам логического сдвига
int addOK(int x, int y); // проверяет,может ли x+ yбыть вычислено без переполнения
int bang(int x); // Вычисляет !x без использования !
int conditional(int x, int y, int z); // аналог тернарного оператора x? y: z
int isPower2(int x); // возвращает 1,если x – степень 2, иначе 0
void main()
{


}
/*
* bitAnd-x&y, используя~ and |
* Пример: bitAnd(6, 5) = 4
* Допустимые операции: ~ |
* Предел операций: 8
*/
int bitAnd(int x, int y)
{
	return ~(~(x) | ~(y));
}
/*
* bitXor -x^y , используя~ and &
* Пример: bitXor(4, 5) = 1
* Допустимые операции: ~ &
* Предел операций: 14
*/
int bitXor(int x, int y)
{
	return ~(~(x) & ~(y)) & ~(x & y);
}
/*
* thirdBits–возвращает int, каждый третий бит которого, считая с младшего, 1, остальные биты 0.
* Допустимые операции: ! ~ & ^ | + << >>
* Предел операций: 8
*/
int thirdBits()
{
	int x = 36; // 100100
	int y = x;
	y = x | (y << 6); // 100100100100
	y = x | (y << 6); // 100100100100100100
	y = x | (y << 6); // 100100100100100100100100
	y = x | (y << 6); // 100100100100100100100100100100
	return y;
}
/*
* fitsBits – возвращает 1, если x может быть представлен на машине с n-разрядами (доп. код)
* 1 <= n <= 32
* Примерs: fitsBits(5,3) = 0, fitsBits(-4,3) = 1
* Допустимые операции: ! ~ & ^ | + << >>
* Предел операций: 15
*/
int fitsBits(int x, int n)
{
	x = x >> (n + ~0); // ~0 = -1 (избегаем вычитания)
	/*
	* положительное вмещается:
	* !x == !0 == 1
	* !(x + 1) == !1 == 0
	* 1 | 0 == 1
	* положительное не вмещается, то
	* !x == !(ненулевое) == 0
	* !(x + 1) == 0
	* 0 | 0 == 0
	* отрицательное вмещается, после сдвига оно будет -1, т.е все биты единицы, тогда
	* !x == 0, а !(x + 1) == 1, 0 | 1 == 1
	* отрицательное не вмещается, то после сдвига будет что-то отрицательное,  не равное -1, и
	* !x == 0, !(x + 1) == 0, 0 | 0 == 0
	*/
	return !x | !(x + 1);
}
/*
* sign–возвращает 1, 0 и -1, если x> 0, x== 0, x< 0 соответственно
* Пример: sign(130) = 1
* sign(-23) = -1
* Допустимые операции: ! ~ &^ | + << >>
* Предел операций: 10
*/
int sign(int x)
{
	return (!!x) | (x >> 31); // !!x позволяет избежать проверки (x != 0)
}
/*
* getByte–извлекает n-ый байт из x
* Нумерация с 0 (младший) to3 (старший)
* Пример: getByte(0x12345678,1) = 0x56
* Допустимые операции: ! ~ & ^ | + << >>
* Предел операций: 6
*/
int getByte(int x, int n)
{
	int mask = 0xff;
	n = n << 3; // n = n*8 (превращаем побитовый сдвиг в побайтовый)
	x = x >> (n); // (делаем младшим нужный нам байт)
	return x & mask; // отбрасываем все байты, кроме последнего
}
/*
* logicalShift – сдвигает биты x вправо по правилам логического сдвига
* 0 <= n <= 31
* Пример: logicalShift(0x87654321,4) = 0x08765432
* Допустимые операции: ~ & ^ | + << >>
* Предел операций: 20
*/
int logicalShift(int x, int n)
{
	int xArithmeticRightShift = x >> n;
	// формируем маску с нужным количеством нулей в старших битах
	int mask = (1 << 31) >> n;
	mask = mask << 1;
	mask = ~mask;
	return xArithmeticRightShift & mask;
}
/*
* addOK–проверяет,может ли x + y быть вычислено без переполнения
* Пример: addOK(0x80000000,0x80000000) = 0,
* addOK(0x80000000,0x70000000) = 1,
* Допустимые операции: ! ~ & ^ | + << >>
* Предел операций: 20
*/
int addOK(int x, int y)
{
	int sum = x + y;
	return!(((sum ^ x) & (sum ^ y)) >> 31);
}
/*
* bang – Вычисляет !x без использования !
* Пример: bang(3) = 0, bang(0) = 1
* Допустимые операции: ~ & ^ | + << >>
* Предел операций: 12
*/
int bang(int x)
{
	return (((~x + 1) | x) >> 31) + 1;
}
/*
* conditional – аналог тернарного оператора x ? y: z
* Пример: conditional(2,4,5) = 4
* Допустимые операции: ! ~ & ^ | + << >>
* Предел операций: 16
*/
int conditional(int x, int y, int z)
{
	return z ^ ((y ^ z) & ((!x) + ~0));
}
/*
* isPower2 -возвращает 1, если x – степень 2, иначе 0
* Примеры: isPower2(5) = 0, isPower2(8) = 1, isPower2(0) = 0
* Отрицательные числа не являются степенью двойки.
* Допустимые операции: ! ~ & ^ | + << >>
* Предел операций: 20
*/
int isPower2(int x)
{
	int mask = x + ~0;
	return !((mask >> 30) | (x & mask));
}
